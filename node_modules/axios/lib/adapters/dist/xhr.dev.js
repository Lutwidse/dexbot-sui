'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = xhrAdapter;

var _utils = _interopRequireDefault(require("./../utils.js"));

var _settle = _interopRequireDefault(require("./../core/settle.js"));

var _cookies = _interopRequireDefault(require("./../helpers/cookies.js"));

var _buildURL = _interopRequireDefault(require("./../helpers/buildURL.js"));

var _buildFullPath = _interopRequireDefault(require("../core/buildFullPath.js"));

var _isURLSameOrigin = _interopRequireDefault(require("./../helpers/isURLSameOrigin.js"));

var _transitional = _interopRequireDefault(require("../defaults/transitional.js"));

var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));

var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));

var _parseProtocol = _interopRequireDefault(require("../helpers/parseProtocol.js"));

var _index = _interopRequireDefault(require("../platform/index.js"));

var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));

var _speedometer2 = _interopRequireDefault(require("../helpers/speedometer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function progressEventReducer(listener, isDownloadStream) {
  var bytesNotified = 0;

  var _speedometer = (0, _speedometer2["default"])(50, 250);

  return function (e) {
    var loaded = e.loaded;
    var total = e.lengthComputable ? e.total : undefined;
    var progressBytes = loaded - bytesNotified;

    var rate = _speedometer(progressBytes);

    var inRange = loaded <= total;
    bytesNotified = loaded;
    var data = {
      loaded: loaded,
      total: total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined
    };
    data[isDownloadStream ? 'download' : 'upload'] = true;
    listener(data);
  };
}

function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;

    var requestHeaders = _AxiosHeaders["default"].from(config.headers).normalize();

    var responseType = config.responseType;
    var onCanceled;

    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (_utils["default"].isFormData(requestData) && _index["default"].isStandardBrowserEnv) {
      requestHeaders.setContentType(false); // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    var fullPath = (0, _buildFullPath["default"])(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), (0, _buildURL["default"])(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      } // Prepare the response


      var responseHeaders = _AxiosHeaders["default"].from('getAllResponseHeaders' in request && request.getAllResponseHeaders());

      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      (0, _settle["default"])(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response); // Clean up request

      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'


        setTimeout(onloadend);
      };
    } // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new _AxiosError["default"]('Request aborted', _AxiosError["default"].ECONNABORTED, config, request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _AxiosError["default"]('Network Error', _AxiosError["default"].ERR_NETWORK, config, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || _transitional["default"];

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(new _AxiosError["default"](timeoutErrorMessage, transitional.clarifyTimeoutError ? _AxiosError["default"].ETIMEDOUT : _AxiosError["default"].ECONNABORTED, config, request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (_index["default"].isStandardBrowserEnv) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || (0, _isURLSameOrigin["default"])(fullPath)) && config.xsrfCookieName && _cookies["default"].read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    } // Remove Content-Type if data is undefined


    requestData === undefined && requestHeaders.setContentType(null); // Add headers to the request

    if ('setRequestHeader' in request) {
      _utils["default"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    } // Add withCredentials to request if needed


    if (!_utils["default"].isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function onCanceled(cancel) {
        if (!request) {
          return;
        }

        reject(!cancel || cancel.type ? new _CanceledError["default"](null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);

      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    var protocol = (0, _parseProtocol["default"])(fullPath);

    if (protocol && _index["default"].protocols.indexOf(protocol) === -1) {
      reject(new _AxiosError["default"]('Unsupported protocol ' + protocol + ':', _AxiosError["default"].ERR_BAD_REQUEST, config));
      return;
    } // Send the request


    request.send(requestData || null);
  });
}