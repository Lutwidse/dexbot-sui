'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = httpAdapter;
exports.__setProxy = void 0;

var _utils = _interopRequireDefault(require("./../utils.js"));

var _settle = _interopRequireDefault(require("./../core/settle.js"));

var _buildFullPath = _interopRequireDefault(require("../core/buildFullPath.js"));

var _buildURL = _interopRequireDefault(require("./../helpers/buildURL.js"));

var _proxyFromEnv = require("proxy-from-env");

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _followRedirects = _interopRequireDefault(require("follow-redirects"));

var _zlib = _interopRequireDefault(require("zlib"));

var _data = require("../env/data.js");

var _transitional = _interopRequireDefault(require("../defaults/transitional.js"));

var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));

var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));

var _index = _interopRequireDefault(require("../platform/index.js"));

var _fromDataURI = _interopRequireDefault(require("../helpers/fromDataURI.js"));

var _stream = _interopRequireDefault(require("stream"));

var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));

var _AxiosTransformStream = _interopRequireDefault(require("../helpers/AxiosTransformStream.js"));

var _events = _interopRequireDefault(require("events"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var isBrotliSupported = _utils["default"].isFunction(_zlib["default"].createBrotliDecompress);

var httpFollow = _followRedirects["default"].http,
    httpsFollow = _followRedirects["default"].https;
var isHttps = /https:?/;

var supportedProtocols = _index["default"].protocols.map(function (protocol) {
  return protocol + ':';
});
/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */


function dispatchBeforeRedirect(options) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }

  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options);
  }
}
/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */


function setProxy(options, configProxy, location) {
  var proxy = configProxy;

  if (!proxy && proxy !== false) {
    var proxyUrl = (0, _proxyFromEnv.getProxyForUrl)(location);

    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }

  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }

      var base64 = Buffer.from(proxy.auth, 'utf8').toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    var proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost; // Replace 'host' since options is not a URL object

    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;

    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : "".concat(proxy.protocol, ":");
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
/*eslint consistent-return:0*/


function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    var data = config.data;
    var responseType = config.responseType;
    var responseEncoding = config.responseEncoding;
    var method = config.method.toUpperCase();
    var isFinished;
    var isDone;
    var rejected = false;
    var req; // temporary internal emitter until the AxiosRequest class will be implemented

    var emitter = new _events["default"]();

    function onFinished() {
      if (isFinished) return;
      isFinished = true;

      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    }

    function done(value, isRejected) {
      if (isDone) return;
      isDone = true;

      if (isRejected) {
        rejected = true;
        onFinished();
      }

      isRejected ? rejectPromise(value) : resolvePromise(value);
    }

    var resolve = function resolve(value) {
      done(value);
    };

    var reject = function reject(value) {
      done(value, true);
    };

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new _CanceledError["default"](null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);

      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    } // Parse url


    var fullPath = (0, _buildFullPath["default"])(config.baseURL, config.url);
    var parsed = new URL(fullPath);
    var protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      var convertedData;

      if (method !== 'GET') {
        return (0, _settle["default"])(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config: config
        });
      }

      try {
        convertedData = (0, _fromDataURI["default"])(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw _AxiosError["default"].from(err, _AxiosError["default"].ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          data = _utils["default"].stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = _stream["default"].Readable.from(convertedData);
      }

      return (0, _settle["default"])(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: {},
        config: config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new _AxiosError["default"]('Unsupported protocol ' + protocol, _AxiosError["default"].ERR_BAD_REQUEST, config));
    }

    var headers = _AxiosHeaders["default"].from(config.headers).normalize(); // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config


    headers.set('User-Agent', 'axios/' + _data.VERSION, false);
    var onDownloadProgress = config.onDownloadProgress;
    var onUploadProgress = config.onUploadProgress;
    var maxRate = config.maxRate;
    var maxUploadRate = undefined;
    var maxDownloadRate = undefined; // support for https://www.npmjs.com/package/form-data api

    if (_utils["default"].isFormData(data) && _utils["default"].isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
    } else if (data && !_utils["default"].isStream(data)) {
      if (Buffer.isBuffer(data)) {// Nothing to do...
      } else if (_utils["default"].isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (_utils["default"].isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new _AxiosError["default"]('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', _AxiosError["default"].ERR_BAD_REQUEST, config));
      } // Add Content-Length header if data exists


      headers.set('Content-Length', data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new _AxiosError["default"]('Request body larger than maxBodyLength limit', _AxiosError["default"].ERR_BAD_REQUEST, config));
      }
    }

    var contentLength = +headers.getContentLength();

    if (_utils["default"].isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!_utils["default"].isStream(data)) {
        data = _stream["default"].Readable.from(data, {
          objectMode: false
        });
      }

      data = _stream["default"].pipeline([data, new _AxiosTransformStream["default"]({
        length: _utils["default"].toFiniteNumber(contentLength),
        maxRate: _utils["default"].toFiniteNumber(maxUploadRate)
      })], _utils["default"].noop);
      onUploadProgress && data.on('progress', function (progress) {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    } // HTTP basic authentication


    var auth = undefined;

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      var urlUsername = parsed.username;
      var urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers["delete"]('authorization');
    var path;

    try {
      path = (0, _buildURL["default"])(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, '');
    } catch (err) {
      var customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set('Accept-Encoding', 'gzip, deflate, br', false);
    var options = {
      path: path,
      method: method,
      headers: headers.toJSON(),
      agents: {
        http: config.httpAgent,
        https: config.httpsAgent
      },
      auth: auth,
      protocol: protocol,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    var transport;
    var isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? _https["default"] : _http["default"];
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }

      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }

      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    } // Create the request


    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      var streams = [res]; // uncompress the response body transparently if required

      var responseStream = res; // return the last request in case of redirects

      var lastRequest = res.req || req; // if decompress disabled we should not decompress

      if (config.decompress !== false) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (data && data.length === 0 && res.headers['content-encoding']) {
          delete res.headers['content-encoding'];
        }

        switch (res.headers['content-encoding']) {
          /*eslint default-case:0*/
          case 'gzip':
          case 'compress':
          case 'deflate':
            // add the unzipper to the body stream processing pipeline
            streams.push(_zlib["default"].createUnzip()); // remove the content-encoding in order to not confuse downstream operations

            delete res.headers['content-encoding'];
            break;

          case 'br':
            if (isBrotliSupported) {
              streams.push(_zlib["default"].createBrotliDecompress());
              delete res.headers['content-encoding'];
            }

        }
      }

      if (onDownloadProgress) {
        var responseLength = +res.headers['content-length'];
        var transformStream = new _AxiosTransformStream["default"]({
          length: _utils["default"].toFiniteNumber(responseLength),
          maxRate: _utils["default"].toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on('progress', function (progress) {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams.push(transformStream);
      }

      responseStream = streams.length > 1 ? _stream["default"].pipeline(streams, _utils["default"].noop) : streams[0];

      var offListeners = _stream["default"].finished(responseStream, function () {
        offListeners();
        onFinished();
      });

      var response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new _AxiosHeaders["default"](res.headers),
        config: config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        (0, _settle["default"])(resolve, reject, response);
      } else {
        var responseBuffer = [];
        var totalResponseBytes = 0;
        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length; // make sure the content length is not over the maxContentLength if specified

          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new _AxiosError["default"]('maxContentLength size of ' + config.maxContentLength + ' exceeded', _AxiosError["default"].ERR_BAD_RESPONSE, config, lastRequest));
          }
        });
        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          var err = new _AxiosError["default"]('maxContentLength size of ' + config.maxContentLength + ' exceeded', _AxiosError["default"].ERR_BAD_RESPONSE, config, lastRequest);
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(_AxiosError["default"].from(err, null, config, lastRequest));
        });
        responseStream.on('end', function handleStreamEnd() {
          try {
            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);

            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);

              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = _utils["default"].stripBOM(responseData);
              }
            }

            response.data = responseData;
          } catch (err) {
            reject(_AxiosError["default"].from(err, null, config, response.request, response));
          }

          (0, _settle["default"])(resolve, reject, response);
        });
      }

      emitter.once('abort', function (err) {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });
    emitter.once('abort', function (err) {
      reject(err);
      req.destroy(err);
    }); // Handle errors

    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(_AxiosError["default"].from(err, null, config, req));
    }); // set tcp keep alive to prevent drop connection by peer

    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    }); // Handle request timeout

    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      var timeout = parseInt(config.timeout, 10);

      if (isNaN(timeout)) {
        reject(new _AxiosError["default"]('error trying to parse `config.timeout` to int', _AxiosError["default"].ERR_BAD_OPTION_VALUE, config, req));
        return;
      } // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.


      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        var transitional = config.transitional || _transitional["default"];

        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }

        reject(new _AxiosError["default"](timeoutErrorMessage, transitional.clarifyTimeoutError ? _AxiosError["default"].ETIMEDOUT : _AxiosError["default"].ECONNABORTED, config, req));
        abort();
      });
    } // Send the request


    if (_utils["default"].isStream(data)) {
      var ended = false;
      var errored = false;
      data.on('end', function () {
        ended = true;
      });
      data.once('error', function (err) {
        errored = true;
        req.destroy(err);
      });
      data.on('close', function () {
        if (!ended && !errored) {
          abort(new _CanceledError["default"]('Request stream has been aborted', config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
}

var __setProxy = setProxy;
exports.__setProxy = __setProxy;