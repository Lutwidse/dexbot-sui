"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var createHash = require("create-hash");

var pbkdf2_1 = require("pbkdf2");

var randomBytes = require("randombytes");

var _wordlists_1 = require("./_wordlists");

var DEFAULT_WORDLIST = _wordlists_1._default;
var INVALID_MNEMONIC = 'Invalid mnemonic';
var INVALID_ENTROPY = 'Invalid entropy';
var INVALID_CHECKSUM = 'Invalid mnemonic checksum';
var WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' + 'Please pass a 2048 word array explicitly.';

function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
  return Promise.resolve().then(function () {
    return new Promise(function (resolve, reject) {
      var callback = function callback(err, derivedKey) {
        if (err) {
          return reject(err);
        } else {
          return resolve(derivedKey);
        }
      };

      pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);
    });
  });
}

function normalize(str) {
  return (str || '').normalize('NFKD');
}

function lpad(str, padString, length) {
  while (str.length < length) {
    str = padString + str;
  }

  return str;
}

function binaryToByte(bin) {
  return parseInt(bin, 2);
}

function bytesToBinary(bytes) {
  return bytes.map(function (x) {
    return lpad(x.toString(2), '0', 8);
  }).join('');
}

function deriveChecksumBits(entropyBuffer) {
  var ENT = entropyBuffer.length * 8;
  var CS = ENT / 32;
  var hash = createHash('sha256').update(entropyBuffer).digest();
  return bytesToBinary(Array.from(hash)).slice(0, CS);
}

function salt(password) {
  return 'mnemonic' + (password || '');
}

function mnemonicToSeedSync(mnemonic, password) {
  var mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
  var saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
  return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
}

exports.mnemonicToSeedSync = mnemonicToSeedSync;

function mnemonicToSeed(mnemonic, password) {
  return Promise.resolve().then(function () {
    var mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
    var saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
    return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
  });
}

exports.mnemonicToSeed = mnemonicToSeed;

function mnemonicToEntropy(mnemonic, wordlist) {
  wordlist = wordlist || DEFAULT_WORDLIST;

  if (!wordlist) {
    throw new Error(WORDLIST_REQUIRED);
  }

  var words = normalize(mnemonic).split(' ');

  if (words.length % 3 !== 0) {
    throw new Error(INVALID_MNEMONIC);
  } // convert word indices to 11 bit binary strings


  var bits = words.map(function (word) {
    var index = wordlist.indexOf(word);

    if (index === -1) {
      throw new Error(INVALID_MNEMONIC);
    }

    return lpad(index.toString(2), '0', 11);
  }).join(''); // split the binary string into ENT/CS

  var dividerIndex = Math.floor(bits.length / 33) * 32;
  var entropyBits = bits.slice(0, dividerIndex);
  var checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare

  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);

  if (entropyBytes.length < 16) {
    throw new Error(INVALID_ENTROPY);
  }

  if (entropyBytes.length > 32) {
    throw new Error(INVALID_ENTROPY);
  }

  if (entropyBytes.length % 4 !== 0) {
    throw new Error(INVALID_ENTROPY);
  }

  var entropy = Buffer.from(entropyBytes);
  var newChecksum = deriveChecksumBits(entropy);

  if (newChecksum !== checksumBits) {
    throw new Error(INVALID_CHECKSUM);
  }

  return entropy.toString('hex');
}

exports.mnemonicToEntropy = mnemonicToEntropy;

function entropyToMnemonic(entropy, wordlist) {
  if (!Buffer.isBuffer(entropy)) {
    entropy = Buffer.from(entropy, 'hex');
  }

  wordlist = wordlist || DEFAULT_WORDLIST;

  if (!wordlist) {
    throw new Error(WORDLIST_REQUIRED);
  } // 128 <= ENT <= 256


  if (entropy.length < 16) {
    throw new TypeError(INVALID_ENTROPY);
  }

  if (entropy.length > 32) {
    throw new TypeError(INVALID_ENTROPY);
  }

  if (entropy.length % 4 !== 0) {
    throw new TypeError(INVALID_ENTROPY);
  }

  var entropyBits = bytesToBinary(Array.from(entropy));
  var checksumBits = deriveChecksumBits(entropy);
  var bits = entropyBits + checksumBits;
  var chunks = bits.match(/(.{1,11})/g);
  var words = chunks.map(function (binary) {
    var index = binaryToByte(binary);
    return wordlist[index];
  });
  return wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093" // Japanese wordlist
  ? words.join("\u3000") : words.join(' ');
}

exports.entropyToMnemonic = entropyToMnemonic;

function generateMnemonic(strength, rng, wordlist) {
  strength = strength || 128;

  if (strength % 32 !== 0) {
    throw new TypeError(INVALID_ENTROPY);
  }

  rng = rng || randomBytes;
  return entropyToMnemonic(rng(strength / 8), wordlist);
}

exports.generateMnemonic = generateMnemonic;

function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch (e) {
    return false;
  }

  return true;
}

exports.validateMnemonic = validateMnemonic;

function setDefaultWordlist(language) {
  var result = _wordlists_1.wordlists[language];

  if (result) {
    DEFAULT_WORDLIST = result;
  } else {
    throw new Error('Could not find wordlist for language "' + language + '"');
  }
}

exports.setDefaultWordlist = setDefaultWordlist;

function getDefaultWordlist() {
  if (!DEFAULT_WORDLIST) {
    throw new Error('No Default Wordlist set');
  }

  return Object.keys(_wordlists_1.wordlists).filter(function (lang) {
    if (lang === 'JA' || lang === 'EN') {
      return false;
    }

    return _wordlists_1.wordlists[lang].every(function (word, index) {
      return word === DEFAULT_WORDLIST[index];
    });
  })[0];
}

exports.getDefaultWordlist = getDefaultWordlist;

var _wordlists_2 = require("./_wordlists");

exports.wordlists = _wordlists_2.wordlists;